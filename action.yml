name: 'Claude Code Changelog'
description: 'Generate changelog using Claude Code based on git diff from last tag'
author: 'mistricky'
branding:
  icon: 'file-text'
  color: 'orange'

inputs:
  github_token:
    description: 'GitHub token with repo access'
    required: true
    default: ${{ github.token }}
  anthropic_api_key:
    description: 'Anthropic API key for Claude'
    required: false
  from_tag:
    description: 'Start tag for diff (defaults to latest tag)'
    required: false
  to_ref:
    description: 'End reference for diff'
    required: false
    default: 'HEAD'
  output_file:
    description: 'Output changelog file path'
    required: false
    default: 'CHANGELOG.md'
  format:
    description: 'Output format (markdown, json)'
    required: false
    default: 'markdown'
  model:
    description: 'Claude model to use'
    required: false
    default: 'claude-3-5-sonnet-20241022'
  use_bedrock:
    description: 'Use Amazon Bedrock'
    required: false
    default: 'false'
  use_vertex:
    description: 'Use Google Vertex AI'
    required: false
    default: 'false'
  bedrock_region:
    description: 'AWS Bedrock region'
    required: false
    default: 'us-east-1'
  vertex_project_id:
    description: 'Google Cloud Project ID'
    required: false
  vertex_region:
    description: 'Google Cloud region'
    required: false
    default: 'us-central1'

outputs:
  changelog:
    description: 'Generated changelog content'
  changelog_file:
    description: 'Path to the generated changelog file'
  changes_count:
    description: 'Number of changes analyzed'

runs:
  using: 'composite'
  steps:
    - name: Prepare git diff for Claude analysis
      id: prepare
      shell: bash
      run: |
        # Get the from tag if not specified
        if [ -z "${{ inputs.from_tag }}" ]; then
          FROM_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$FROM_TAG" ]; then
            echo "No tags found, using initial commit"
            FROM_TAG=$(git rev-list --max-parents=0 HEAD)
          fi
        else
          FROM_TAG="${{ inputs.from_tag }}"
        fi
        
        TO_REF="${{ inputs.to_ref }}"
        
        echo "from_tag=$FROM_TAG" >> $GITHUB_OUTPUT
        echo "to_ref=$TO_REF" >> $GITHUB_OUTPUT
        
        # Get git log and diff
        echo "Getting changes from $FROM_TAG to $TO_REF"
        
        # Create comprehensive diff analysis
        git log --oneline "$FROM_TAG..$TO_REF" > /tmp/commits.log || true
        git diff --stat "$FROM_TAG..$TO_REF" > /tmp/diff_stat.log || true
        git diff "$FROM_TAG..$TO_REF" > /tmp/full_diff.log || true
        
        # Count commits and files
        COMMIT_COUNT=$(git rev-list --count "$FROM_TAG..$TO_REF" 2>/dev/null || echo "0")
        echo "changes_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
        
        # Create analysis prompt
        cat > /tmp/changelog_prompt.md << 'EOF'
        You are a technical writer creating a changelog for a software project. Based on the git changes provided, generate a well-structured changelog entry.

        Please analyze the following git changes and generate a professional changelog in markdown format:

        ## Commits:
        ```
        $(cat /tmp/commits.log 2>/dev/null || echo "No commits found")
        ```

        ## File Changes Summary:
        ```
        $(cat /tmp/diff_stat.log 2>/dev/null || echo "No file changes found")
        ```

        ## Detailed Changes:
        ```
        $(head -200 /tmp/full_diff.log 2>/dev/null || echo "No detailed changes available")
        ```

        ## Instructions:
        1. **Categorize changes** using standard changelog categories:
           - **Added**: New features
           - **Changed**: Changes in existing functionality
           - **Deprecated**: Soon-to-be removed features
           - **Removed**: Removed features
           - **Fixed**: Bug fixes
           - **Security**: Security improvements

        2. **Write clear, user-focused descriptions** that explain:
           - What changed from a user's perspective
           - Why it matters
           - Any breaking changes or migration notes

        3. **Use consistent formatting**:
           - Each item should be a concise bullet point
           - Start with an action verb when possible
           - Group related changes together

        4. **Focus on semantic meaning** rather than technical implementation details

        Please generate only the changelog content in markdown format without any explanatory text or metadata. Do not include version numbers or dates.
        EOF

    - name: Generate changelog with Claude Code
      id: claude
      uses: anthropics/claude-code-action@beta 
      with:
        github_token: ${{ inputs.github_token }}
        anthropic_api_key: ${{ inputs.anthropic_api_key }}
        use_bedrock: ${{ inputs.use_bedrock }}
        use_vertex: ${{ inputs.use_vertex }}
        bedrock_region: ${{ inputs.bedrock_region }}
        vertex_project_id: ${{ inputs.vertex_project_id }}
        vertex_region: ${{ inputs.vertex_region }}
        model: ${{ inputs.model }}
        direct_prompt: |
          Read the changelog generation prompt from /tmp/changelog_prompt.md and generate a professional changelog based on the git analysis provided.
          
          Output the generated changelog to a file named 'generated_changelog.md'.
          
          The changelog should be well-structured, use appropriate markdown formatting, and follow conventional changelog standards.

    - name: Process and output results
      id: output
      shell: bash
      run: |
        # Check if changelog was generated
        if [ -f "generated_changelog.md" ]; then
          echo "Changelog generated successfully"
          
          # Read the generated changelog
          CHANGELOG_CONTENT=$(cat generated_changelog.md)
          
          # Handle output file
          OUTPUT_FILE="${{ inputs.output_file }}"
          if [ "$OUTPUT_FILE" != "stdout" ]; then
            cp generated_changelog.md "$OUTPUT_FILE"
            echo "Changelog written to $OUTPUT_FILE"
          fi
          
          # Set outputs using heredoc to handle multiline content
          {
            echo 'changelog<<EOF'
            cat generated_changelog.md
            echo EOF
          } >> $GITHUB_OUTPUT
          
          echo "changelog_file=$OUTPUT_FILE" >> $GITHUB_OUTPUT
          echo "changes_count=${{ steps.prepare.outputs.changes_count }}" >> $GITHUB_OUTPUT
          
        else
          echo "Failed to generate changelog, creating fallback"
          
          # Create fallback changelog
          FALLBACK="## Changes\n\nAutomated release with ${{ steps.prepare.outputs.changes_count }} commits.\n\nFrom: ${{ steps.prepare.outputs.from_tag }}\nTo: ${{ steps.prepare.outputs.to_ref }}"
          
          echo -e "$FALLBACK" > fallback_changelog.md
          
          OUTPUT_FILE="${{ inputs.output_file }}"
          if [ "$OUTPUT_FILE" != "stdout" ]; then
            cp fallback_changelog.md "$OUTPUT_FILE"
          fi
          
          {
            echo 'changelog<<EOF'
            echo -e "$FALLBACK"
            echo EOF
          } >> $GITHUB_OUTPUT
          
          echo "changelog_file=$OUTPUT_FILE" >> $GITHUB_OUTPUT
          echo "changes_count=${{ steps.prepare.outputs.changes_count }}" >> $GITHUB_OUTPUT
        fi
